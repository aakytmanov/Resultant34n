Resultant34n:=module()
export RecurrNewton, Res3d, Res4d;

option package;


RecurrNewton:=proc(A,k)
 local j,m,S,t:
 m:=nops(A):
 S:=[-A[m]]:
 for j from 2 to min(k,m) do
  t:=`+`(op(zip((x,y)->x*y,S[1..j-1],A[m-j+2..m]))):
  S:=[op(S),-expand(t)-j*A[m-j+1]]:
 end do:
 if k>m then
  for j from m+1 to k do
   t:=`+`(op(zip((x,y)->x*y,S[j-m..j-1],A[1..m]))):
   S:=[op(S),-expand(t)]:
  end do:
 end if:
 return(S):
end proc:

Res3d:=proc(f,g,z,nn)
 local i,A,An,B,B2,m,n,N,R,S,s,t,p,P,pow,Cp:

 m:=degree(f,z):
 pow:=[seq(z^i,i=1..m-1)]:
 A:=coeff(f,z,0):
 A:=[A, op(map(z->coeff(f,z),pow))]:

 if type(g, polynom)=true then
  P:=g:
 else
  P:=convert(series(g,z,nn),polynom):
 end if:
 n:=degree(P,z)+1:
 pow:=[seq(z^i,i=1..n-1)]:
 B:=coeff(P,z,0):
 B:=[B, op(map(z->coeff(P,z),pow))]:

 S:=RecurrNewton(A,2*n):
 N:=[seq(i,i=1..n)]:
 An:=map(x->((-1)^m*A[1])^(x-1),N):
 B2:=map(x->x^m,B):
 R:=`+`(op(zip((x,y)->x*y,An,B2))):
 for s from 1 to n do
  for t from s+1 to n do
   R:=R+(-A[1])^(s-1)*(1/2*B[s]*B[t]^2*(S[t-s]^2-S[2*(t-s)])+B[s]^2*B[t]*S[t-s]):
  end do:
 end do:
 for s from 1 to n do
  for t from s+1 to n do
   for p from t+1 to n do
    R:=R+(-A[1])^(s-1)*B[s]*B[t]*B[p]*(S[t-s]*S[p-s]-S[t+p-2*s]):
   end do:
  end do:
 end do:
 return(R):
end proc:


Res4d:=proc(f,g,z,nn)
 local i,A,An,B,B2,m,n,N,P,R,S,s,t,p,r,pow:

 m:=degree(f,z):
 pow:=[seq(z^i,i=1..m-1)]:
 A:=coeff(f,z,0):
 A:=[A, op(map(z->coeff(f,z),pow))]:

 if type(g, polynom)=true then
  P:=g:
 else
  P:=convert(series(g,z,nn),polynom):
 end if:
 n:=degree(P,z)+1:
 pow:=[seq(z^i,i=1..n-1)]:
 B:=coeff(P,z,0):
 B:=[B, op(map(z->coeff(P,z),pow))]:

 S:=RecurrNewton(A,3*n):
 N:=[seq(i,i=1..n)]:
 An:=map(x->((-1)^m*A[1])^(x-1),N):
 B2:=map(x->x^m,B):
 R:=`+`(op(zip((x,y)->x*y,An,B2))):

 for s from 1 to n do
  for t from s+1 to n do
   R:=R+A[1]^(s-1)*(B[s]^3*B[t]*S[t-s] + 
B[s]*B[t]^3/4*(S[t-s]^3-3*S[2*(t-s)]*S[t-s]+2*S[3*(t-s)]) + 
B[s]^2*B[t]^2/2*(S[t-s]^2-S[2*(t-s)]))
  end do:
 end do:

 for s from 1 to n do
  for t from s+1 to n do
   for p from t+1 to n do
    R:=R+A[1]^(s-1)*(
B[s]^2*B[t]*B[p]*(S[p-s]*S[t-s]-S[p+t-2*s]) + 
B[s]*B[t]^2*B[p]/2*(S[t-s]^2*S[p-s]-S[2*(t-s)]*S[p-s]-2*S[t+p-2*s]*S[t-s]+2*S[2*t+p-3*s]) + 
B[s]*B[t]*B[p]^2/2*(S[p-s]^2*S[t-s]-S[2*(p-s)]*S[t-s]-2*S[t+p-2*s]*S[p-s]+2*S[2*p+t-3*s])
):
   end do:
  end do:
 end do:

for s from 1 to n do
  for t from s+1 to n do
   for p from t+1 to n do
    for r from p+1 to n do
     R:=R+A[1]^(s-1)*B[s]*B[t]*B[p]*B[r]*(S[t-s]*S[p-s]*S[r-s]-S[t+p-2*s]*S[r-s]-S[t+r-2*s]*S[p-s]-S[p+r-2*s]*S[t-s]+2*S[t+p+r-3*s]):
    end do:
   end do:
  end do:
 end do:

 return(R):
end proc:

end module: